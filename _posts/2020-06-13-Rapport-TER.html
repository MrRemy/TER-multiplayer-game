---
title: RAPPORT TER
layout: default
---


<div>
    <h2> Introduction </h2>
    <h3> Présentation du groupe </h3>
    <p> Encadrant : Michel Buffa </p>
    <p>
        <br> SAMAK Maxime </br>
        <br> MUNIER Rémy </br>
        <br> VASSEUR Adrien </br>
        <br> HALLACI Sabri </br>
    </p>

    <h3> Présentation du sujet </h3>
    <p>
        Le but de ce TER est de mettre en place des algorithmes de détection et de correction de latence, sur un jeu multijoueur réactif en ligne, puis de tester leurs efficacités et leurs limites. Pour ce faire, nous avons recréé un jeu de type "argar.io" et allons travailler dessus. Nous utiliserons des algorithmes tel que "Prediction" et "Interpolation", nous les testerons avec des latences élevées et/ou variables, ainsi qu'avec une multitude de joueurs pour découvrir leurs limites.
    </p>
</div>

<div>
    <h2> Technologies utilisés </h2>

    <h3> socket.io </h3>
    <p> <a href="http://socket.io">socket.io</a> est un outil puissant permettant la communication  en temps réel entre un serveur et un ou plusieurs clients. Sa compatibilité avec des technologies récentes tel que les web sockets, mais aussi avec des basiques du networking comme JSON, ... le rende très flexible.
    </p>
    <p> Sa simplicité d'utilisation et notre familiarité avec cette technologie (utilisation lors de différents projets) nous ont poussés à son utilisation pour ce TER.</p>

    <h3> node.js </h3>
    <p> <a href="https://nodejs.org/fr/">node.js</a> est un outil facile d'accès et polyvalent, il est en effet aisé d'héberger un projet node.js de par son support par la plupart des fournisseurs d'hébergement, de même son déploiement sur un serveur personnel ne présente pas de difficultés. </p>
    <p>Un grand nombre de modules sont disponibles pour node.js et parmi ces derniers on fera surtout mention d'<a href="http://expressjs.com/">Express</a> couvrant pour nous la totalité des interactions entre notre client et le serveur.
    </p>

    <h3> p5.js </h3>
    <p> <a href="https://p5js.org/">p5.js</a> est une librairie permettant une certaine facilité dans le développement de contenu créatif, ainsi elle est toute indiquée pour l'élaboration d'un jeu.
     </p>

    <h3> Heroku </h3>
    <p> <a href="https://www.heroku.com/">Heroku</a> est une plateforme d'hébergement orientée cloud, qui nous permet d'héberger notre projet node.js sur un serveur distant, permettant un réel impact sur les vitesses de connections et le multijoueurs de notre projet.
    </p>
</div>

<div>
    <h2> Jeu multijoueurs en temps réel </h2>
    <p> Un jeu multijoueur dit "en temps réel" est un jeu ou les joueurs jouent simultanément, ainsi si l'un se déplace, il doit se déplacer "instantanément" aussi sur les écrans des autres joueurs. Ex : FPS, Mario Kart, agar.io ...
    </p>

    <h3> Networking client-serveur </h3>
    <p>
        Le jeu tourne à l'aide de nodes.js utilisant socket.io pour créer une communication websocket avec un ou plusieurs clients se connectant sur le port 3000 (par défaut).

        <br>
        <img src="{{site.baseurl}}/assets/images/client_server_com.png" alt="connection">
        <img src="/assets/images/RTT.png" alt="">
        <br>

        On peut séparer la communication d'un client au serveur en trois étapes distinctes:
        <ol>
            <li> Le client qui se connecte se voit affecter un identifiant unique, et est ajouté à la liste des joueurs actuellement connectés au serveur. On lui attribue également une position de départ ainsi que des informations pour la représentation de son personnage (taille, couleur, ...). </li>
            <li> Le client va ensuite communiquer au serveur la direction vers laquelle il souhaite se déplacer (via tracking de la souris). Le serveur reçoit ces informations les traites et procède aux différentes modifications sur l'état du jeu. </li>
            <li> Périodiquement le serveur va broadcaster la liste des joueurs avec leurs informations mises à jour ainsi que l'état courant du jeu. </li>
        </ol>
        Les étapes 2 et 3 sont reproduites 10 fois par seconde (par défaut), le taux de rafraîchissement du serveur est modifiable via un curseur sur l'interface client.
    </p>

    <h4> Client </h4>
    <p> Le client est la partie du jeu qui s'ouvre dans votre browser, il a la charge de communiquer avec le serveur et de toute la partie graphique du jeu à savoir :
        <ul>
            <li> Le rendu visuel du jeu sur un canvas </li>
            <li> La gestion du menu pour les options </li>
            <li> Le rendu visuel de la courbe de latence </li>
        </ul>
    </p>
    <p> De plus c'est le client qui à l'aide d'algorithmes de prédiction va permettre à l'utilisateur d'avoir une sensation d'agir sur le jeu instantanément à partir d'une dizaine (voir moins) d'updates du serveur à la seconde. Ainsi on pourra même conserver une impression d'avoir 60 fps avec seulement 3 ou 4 updates dans le pire des cas. </p>

    <h4> Serveur </h4>
    <p> C'est sur le serveur que toute la logique du jeu va s'opérer, à partir des directions envoyés par les clients, il va calculer les nouvelles positions des joueurs et changer l'état du jeu en conséquence. </p>
    <p> A chaque update le serveur procède aux opérations suivantes:
        <ul>
            <li>Calcul des nouvelles positions des joueurs à l'aide des vecteurs de position envoyés</li>
            <li>Recherche de collisions entre joueurs</li>
            <li>Recherche de collisions entre les joueurs et les éléments du jeu</li>
            <li>Mise à jour des informations des joueurs</li>
            <li>Broadcast des nouvelles informations</li>

        </ul>
    </p>
    <p> La centralisation de la logique permet à la fois d'éviter toute triche de la part des joueurs, ainsi que de limiter les échanges nécessaires pour faire tourner correctement le jeu (ce choix d'architecture sera détaillé ultérieurement dans le rapport). </p>


    <h3> Hardware et Browser </h3>
    <p> Toutes les machines ne sont pas équivalentes en termes de puissance et donc de rapidité, il en va de même pour les browsers qui de par leurs spécificités propres n'auront pas toujours la même efficacité pour une tâche donnée. </p>
    <p> Une étape essentielle du développement d'un jeu web est donc de pallier à ces inégalités qui toucheront les utilisateurs. </p>

    <h4> Frame rate </h4>
    <p> Prenons un exemple simple pour illustrer ce phénomène : un block se trouve sur un axe X, il se déplace sur cet axe de +1 pixel par frame. Ainsi le joueur A qui fait tourner son jeu à 30 fps verra se déplacer ce block de 30 pixels sur l'axe X en 1 seconde, seulement le joueur B ayant un ordinateur plus performant et ayant 60 fps verra ce même block se déplacer de 60 pixels en 1 seconde. </p>

    <p> Il y a là un véritable problème !</p>

    <p> Solution : pour s'assurer que notre block se déplace toujours à la même vitesse nous allons introduire un concept de delta de temps entre deux rafraîchissements. Cette valeur, exprimée en millisecondes, représente le temps écoulé entre deux itérations de notre boucle de rendu graphique. </p>
    <p> À 30 fps on a donc un delta d'environ 33.3 ms, et à 60 fps on obtient environ 16.66 ms pour notre delta, on peut désormais multiplier notre valeur de déplacement (+1 sur l'axe x) par nos delta pour obtenir un mouvement à 1 pixel par seconde pour nos deux joueurs.</p>

    <br>
    <img src="{{site.baseurl}}/assets/images/delta.png" alt="Delta">
    </br>

    <p> Si cet exemple porte uniquement sur les frames rate il ne faut pas oublier que le même principe devrait être appliqué pour toutes valeurs subissant un changement au cours du temps de manière a assurer une cohérence du jeu pour l'ensemble des joueurs. </p>

    <h4> Calcul de la latence </h4>
    <p>

        <br>
            <img src="{{site.baseurl}}/assets/images/RTT.png" alt="Round trip time (RTT)">
        </br>
    </p>

    <h3> Autre </h3>
    <p> On pourra également noter la présence d'un panneau de contrôle permettant d'activer/désactiver les codes de prédiction/interpolation/... à la volée ainsi que de modifier certains attributs du serveur.</p>

    <h2>Algorithmes</h2>
    <h3>Prédiction client</h3>
    <p>Comme nous l'avons dis, c'est le serveur qui calcule la position des joueurs, le client va envoyer son vecteur de mouvement lors de sa boucle, ce message va arriver au serveur après un décalage équivalent au temps de latence, le serveur calcule puis renvoie la position au client dans sa prochaine boucle d'update, le message arrive après un nouveau décalage. Il est donc équivalent qu'en utilisant cette méthode pour calculer la position un long décalage et le joueur va bouger bien après avoir bougé la souris.</p>
    <p>C'est ici qu'entre en fonction l'algorithme de prédiction client :</p>
    <p>Le client va calculer lui-même sa position avec son vecteur de mouvement, tout en continuant à envoyer ce vecteur au serveur. Le client met à jour sa position seul ce qui évite les décalages et les "sauts" dûs à la latence.</p>
    <p>De son côté, le serveur calcule la position de ce même joueurs, en prenant en compte le moment de l'envoi, ainsi lorsque le serveur notifie le joueur de sa nouvelle position, celui-ci devrait déjà s'y trouver, si non, sa position est corrigé côté client, ce qui évite les différence de position entre client et serveur.</p>
    <h4>Prédiction client :</h4>
    <pre>
        if (alive) {
            //speed
            let sp = 20;

            let newPosition = createVector(mouseX - width / 2, mouseY - height / 2);
            newPosition.setMag(4);
            newPosition.x = newPosition.x * (delta / sp);
            newPosition.y = newPosition.y * (delta / sp);

            bubble.position.x += newPosition.x;
            bubble.position.y += newPosition.y;

            //bubble.position = createVector(self.x, self.y);
            bubble.radius = self.radius;

            if (bubble.position.x > 3000 - bubble.radius) { bubble.position.x = 3000 - bubble.radius}
            else if (bubble.position.x < -3000 + bubble.radius) { bubble.position.x = -3000 + bubble.radius}
            if (bubble.position.y > 3000 - bubble.radius) { bubble.position.y = 3000 - bubble.radius}
            else if (bubble.position.y < -3000 + bubble.radius) { bubble.position.y = -3000 + bubble.radius}
        }
    </pre>

    <h2>Démo live</h2>
    <p>Cette démo live a été extraite de l'article <a href="https://www.gabrielgambetta.com/client-side-prediction-live-demo.html">suivant</a> par Gabriel Gambetta et fournis par M. Buffa. L'implémentation et les algorithmes ne sont donc pas les nôtres, mais cette démo est une représentation efficace et proche de leur efficacité, ainsi nous avons trouver perspicace de l'intégrer à ce rapport.</p>
    <p>Cette démo vous propose de tester les trois algorithmes avec deux joueurs se déplaçant en 2D, la latence de chaque joueur est simulée et réglable, tout comme le nombre d'updates serveur par seconde.</p>

    <div style="border: 5px solid blue; padding: 15px;">
        <p><b>Player 1 view</b> - move with LEFT and RIGHT arrow keys<br> Lag = <input type="text" id="player1_lag" size=5 value="250" onchange="updateParameters();">ms</input> · <input type="checkbox" id="player1_prediction" onchange="updateParameters();">Prediction</input> · <input type="checkbox" id="player1_reconciliation" onchange="updateParameters();">Reconciliation</input> · <input type="checkbox" id="player1_interpolation" onchange="updateParameters();">Interpolation</input></p>
        <canvas id="player1_canvas" width="920" height="75">
        </canvas>
        <div id="player1_status" style="font-family:courier;">
            Waiting for connection…
        </div>
    </div>
    <div style="height: 1em;">

    </div>
    <div style="border: 2px solid grey; padding: 15px;">
        <p><b>Server view</b> · Update <input type="text" id="server_fps" size=5 value="3" onchange="updateParameters();"> times per second</input></p>
        <canvas id="server_canvas" width="920" height="75">
        </canvas>
        <div id="server_status" style="font-family:courier;">

        </div>
    </div>
    <div style="height: 1em;">

    </div>
    <div style="border: 5px solid red; padding: 15px;">
        <p><b>Player 2 view</b> - move with A and D keys<br> Lag = <input type="text" id="player2_lag" size=5 value="150" onchange="updateParameters();">ms</input> · <input type="checkbox" id="player2_prediction" onchange="updateParameters();">Prediction</input> · <input type="checkbox" id="player2_reconciliation" onchange="updateParameters();">Reconciliation</input> · <input type="checkbox" id="player2_interpolation" onchange="updateParameters();">Interpolation</input></p>
        <canvas id="player2_canvas" width="920" height="75">
        </canvas>
        <div id="player2_status" style="font-family:courier;">
            Waiting for connection…
        </div>
    </div>
    <script>

        // =============================================================================
        //  An Entity in the world.
        // =============================================================================
        var Entity = function() {
            this.x = 0;
            this.speed = 2; // units/s
            this.position_buffer = [];
        }

        // Apply user's input to this entity.
        Entity.prototype.applyInput = function(input) {
            this.x += input.press_time*this.speed;
        }


        // =============================================================================
        //  A message queue with simulated network lag.
        // =============================================================================
        var LagNetwork = function() {
            this.messages = [];
        }

        // "Send" a message. Store each message with the timestamp when it should be
        // received, to simulate lag.
        LagNetwork.prototype.send = function(lag_ms, message) {
            this.messages.push({recv_ts: +new Date() + lag_ms,
                payload: message});
        }

        // Returns a "received" message, or undefined if there are no messages available
        // yet.
        LagNetwork.prototype.receive = function() {
            var now = +new Date();
            for (var i = 0; i < this.messages.length; i++) {
                var message = this.messages[i];
                if (message.recv_ts <= now) {
                    this.messages.splice(i, 1);
                    return message.payload;
                }
            }
        }


        // =============================================================================
        //  The Client.
        // =============================================================================
        var Client = function(canvas, status) {
            // Local representation of the entities.
            this.entities = {};

            // Input state.
            this.key_left = false;
            this.key_right = false;

            // Simulated network connection.
            this.network = new LagNetwork();
            this.server = null;
            this.lag = 0;

            // Unique ID of our entity. Assigned by Server on connection.
            this.entity_id = null;

            // Data needed for reconciliation.
            this.client_side_prediction = false;
            this.server_reconciliation = false;
            this.input_sequence_number = 0;
            this.pending_inputs = [];

            // Entity interpolation toggle.
            this.entity_interpolation = true;

            // UI.
            this.canvas = canvas;
            this.status = status;

            // Update rate.
            this.setUpdateRate(50);
        }


        Client.prototype.setUpdateRate = function(hz) {
            this.update_rate = hz;

            clearInterval(this.update_interval);
            this.update_interval = setInterval(
                (function(self) { return function() { self.update(); }; })(this),
                1000 / this.update_rate);
        }


        // Update Client state.
        Client.prototype.update = function() {
            // Listen to the server.
            this.processServerMessages();

            if (this.entity_id == null) {
                return;  // Not connected yet.
            }

            // Process inputs.
            this.processInputs();

            // Interpolate other entities.
            if (this.entity_interpolation) {
                this.interpolateEntities();
            }

            // Render the World.
            renderWorld(this.canvas, this.entities);

            // Show some info.
            var info = "Non-acknowledged inputs: " + this.pending_inputs.length;
            this.status.textContent = info;
        }


        // Get inputs and send them to the server.
        // If enabled, do client-side prediction.
        Client.prototype.processInputs = function() {
            // Compute delta time since last update.
            var now_ts = +new Date();
            var last_ts = this.last_ts || now_ts;
            var dt_sec = (now_ts - last_ts) / 1000.0;
            this.last_ts = now_ts;

            // Package player's input.
            var input;
            if (this.key_right) {
                input = { press_time: dt_sec };
            } else if (this.key_left) {
                input = { press_time: -dt_sec };
            } else {
                // Nothing interesting happened.
                return;
            }

            // Send the input to the server.
            input.input_sequence_number = this.input_sequence_number++;
            input.entity_id = this.entity_id;
            this.server.network.send(this.lag, input);

            // Do client-side prediction.
            if (this.client_side_prediction) {
                this.entities[this.entity_id].applyInput(input);
            }

            // Save this input for later reconciliation.
            this.pending_inputs.push(input);
        }


        // Process all messages from the server, i.e. world updates.
        // If enabled, do server reconciliation.
        Client.prototype.processServerMessages = function() {
            while (true) {
                var message = this.network.receive();
                if (!message) {
                    break;
                }

                // World state is a list of entity states.
                for (var i = 0; i < message.length; i++) {
                    var state = message[i];

                    // If this is the first time we see this entity, create a local representation.
                    if (!this.entities[state.entity_id]) {
                        var entity = new Entity();
                        entity.entity_id = state.entity_id;
                        this.entities[state.entity_id] = entity;
                    }

                    var entity = this.entities[state.entity_id];

                    if (state.entity_id == this.entity_id) {
                        // Received the authoritative position of this client's entity.
                        entity.x = state.position;

                        if (this.server_reconciliation) {
                            // Server Reconciliation. Re-apply all the inputs not yet processed by
                            // the server.
                            var j = 0;
                            while (j < this.pending_inputs.length) {
                                var input = this.pending_inputs[j];
                                if (input.input_sequence_number <= state.last_processed_input) {
                                    // Already processed. Its effect is already taken into account into the world update
                                    // we just got, so we can drop it.
                                    this.pending_inputs.splice(j, 1);
                                } else {
                                    // Not processed by the server yet. Re-apply it.
                                    entity.applyInput(input);
                                    j++;
                                }
                            }
                        } else {
                            // Reconciliation is disabled, so drop all the saved inputs.
                            this.pending_inputs = [];
                        }
                    } else {
                        // Received the position of an entity other than this client's.

                        if (!this.entity_interpolation) {
                            // Entity interpolation is disabled - just accept the server's position.
                            entity.x = state.position;
                        } else {
                            // Add it to the position buffer.
                            var timestamp = +new Date();
                            entity.position_buffer.push([timestamp, state.position]);
                        }
                    }
                }
            }
        }


        Client.prototype.interpolateEntities = function() {
            // Compute render timestamp.
            var now = +new Date();
            var render_timestamp = now - (1000.0 / server.update_rate);

            for (var i in this.entities) {
                var entity = this.entities[i];

                // No point in interpolating this client's entity.
                if (entity.entity_id == this.entity_id) {
                    continue;
                }

                // Find the two authoritative positions surrounding the rendering timestamp.
                var buffer = entity.position_buffer;

                // Drop older positions.
                while (buffer.length >= 2 && buffer[1][0] <= render_timestamp) {
                    buffer.shift();
                }

                // Interpolate between the two surrounding authoritative positions.
                if (buffer.length >= 2 && buffer[0][0] <= render_timestamp && render_timestamp <= buffer[1][0]) {
                    var x0 = buffer[0][1];
                    var x1 = buffer[1][1];
                    var t0 = buffer[0][0];
                    var t1 = buffer[1][0];

                    entity.x = x0 + (x1 - x0) * (render_timestamp - t0) / (t1 - t0);
                }
            }
        }


        // =============================================================================
        //  The Server.
        // =============================================================================
        var Server = function(canvas, status) {
            // Connected clients and their entities.
            this.clients = [];
            this.entities = [];

            // Last processed input for each client.
            this.last_processed_input = [];

            // Simulated network connection.
            this.network = new LagNetwork();

            // UI.
            this.canvas = canvas;
            this.status = status;

            // Default update rate.
            this.setUpdateRate(10);
        }

        Server.prototype.connect = function(client) {
            // Give the Client enough data to identify itself.
            client.server = this;
            client.entity_id = this.clients.length;
            this.clients.push(client);

            // Create a new Entity for this Client.
            var entity = new Entity();
            this.entities.push(entity);
            entity.entity_id = client.entity_id;

            // Set the initial state of the Entity (e.g. spawn point)
            var spawn_points = [4, 6];
            entity.x = spawn_points[client.entity_id];
        }

        Server.prototype.setUpdateRate = function(hz) {
            this.update_rate = hz;

            clearInterval(this.update_interval);
            this.update_interval = setInterval(
                (function(self) { return function() { self.update(); }; })(this),
                1000 / this.update_rate);
        }

        Server.prototype.update = function() {
            this.processInputs();
            this.sendWorldState();
            renderWorld(this.canvas, this.entities);
        }


        // Check whether this input seems to be valid (e.g. "make sense" according
        // to the physical rules of the World)
        Server.prototype.validateInput = function(input) {
            if (Math.abs(input.press_time) > 1/40) {
                return false;
            }
            return true;
        }


        Server.prototype.processInputs = function() {
            // Process all pending messages from clients.
            while (true) {
                var message = this.network.receive();
                if (!message) {
                    break;
                }

                // Update the state of the entity, based on its input.
                // We just ignore inputs that don't look valid; this is what prevents clients from cheating.
                if (this.validateInput(message)) {
                    var id = message.entity_id;
                    this.entities[id].applyInput(message);
                    this.last_processed_input[id] = message.input_sequence_number;
                }

            }

            // Show some info.
            var info = "Last acknowledged input: ";
            for (var i = 0; i < this.clients.length; ++i) {
                info += "Player " + i + ": #" + (this.last_processed_input[i] || 0) + "   ";
            }
            this.status.textContent = info;
        }


        // Send the world state to all the connected clients.
        Server.prototype.sendWorldState = function() {
            // Gather the state of the world. In a real app, state could be filtered to avoid leaking data
            // (e.g. position of invisible enemies).
            var world_state = [];
            var num_clients = this.clients.length;
            for (var i = 0; i < num_clients; i++) {
                var entity = this.entities[i];
                world_state.push({entity_id: entity.entity_id,
                    position: entity.x,
                    last_processed_input: this.last_processed_input[i]});
            }

            // Broadcast the state to all the clients.
            for (var i = 0; i < num_clients; i++) {
                var client = this.clients[i];
                client.network.send(client.lag, world_state);
            }
        }


        // =============================================================================
        //  Helpers.
        // =============================================================================

        // Render all the entities in the given canvas.
        var renderWorld = function(canvas, entities) {
            // Clear the canvas.
            canvas.width = canvas.width;

            var colours = ["blue", "red"];

            for (var i in entities) {
                var entity = entities[i];

                // Compute size and position.
                var radius = canvas.height*0.9/2;
                var x = (entity.x / 10.0)*canvas.width;

                // Draw the entity.
                var ctx = canvas.getContext("2d");
                ctx.beginPath();
                ctx.arc(x, canvas.height / 2, radius, 0, 2*Math.PI, false);
                ctx.fillStyle = colours[entity.entity_id];
                ctx.fill();
                ctx.lineWidth = 5;
                ctx.strokeStyle = "dark" + colours[entity.entity_id];
                ctx.stroke();
            }
        }


        var element = function(id) {
            return document.getElementById(id);
        }

        // =============================================================================
        //  Get everything up and running.
        // =============================================================================

        // World update rate of the Server.
        var server_fps = 4;


        // Update simulation parameters from UI.
        var updateParameters = function() {
            updatePlayerParameters(player1, "player1");
            updatePlayerParameters(player2, "player2");
            server.setUpdateRate(updateNumberFromUI(server.update_rate, "server_fps"));
            return true;
        }


        var updatePlayerParameters = function(client, prefix) {
            client.lag = updateNumberFromUI(player1.lag, prefix + "_lag");

            var cb_prediction = element(prefix + "_prediction");
            var cb_reconciliation = element(prefix + "_reconciliation");

            // Client Side Prediction disabled => disable Server Reconciliation.
            if (client.client_side_prediction && !cb_prediction.checked) {
                cb_reconciliation.checked = false;
            }

            // Server Reconciliation enabled => enable Client Side Prediction.
            if (!client.server_reconciliation && cb_reconciliation.checked) {
                cb_prediction.checked = true;
            }

            client.client_side_prediction = cb_prediction.checked;
            client.server_reconciliation = cb_reconciliation.checked;

            client.entity_interpolation = element(prefix + "_interpolation").checked;
        }


        var updateNumberFromUI = function(old_value, element_id) {
            var input = element(element_id);
            var new_value = parseInt(input.value);
            if (isNaN(new_value)) {
                new_value = old_value;
            }
            input.value = new_value;
            return new_value;
        }


        // When the player presses the arrow keys, set the corresponding flag in the client.
        var keyHandler = function(e) {
            e = e || window.event;
            if (e.keyCode == 39) {
                player1.key_right = (e.type == "keydown");
            } else if (e.keyCode == 37) {
                player1.key_left = (e.type == "keydown");
            } else if (e.key == 'd') {
                player2.key_right = (e.type == "keydown");
            } else if (e.key == 'a') {
                player2.key_left = (e.type == "keydown");
            } else {
                console.log(e)
            }
        }
        document.body.onkeydown = keyHandler;
        document.body.onkeyup = keyHandler;


        // Setup a server, the player's client, and another player.
        var server = new Server(element("server_canvas"), element("server_status"));
        var player1 = new Client(element("player1_canvas"), element("player1_status"));
        var player2 = new Client(element("player2_canvas"), element("player2_status"));


        // Connect the clients to the server.
        server.connect(player1);
        server.connect(player2);


        // Read initial parameters from the UI.
        updateParameters();

    </script>


</div>
