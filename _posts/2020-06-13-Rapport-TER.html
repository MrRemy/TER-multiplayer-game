---
title: RAPPORT TER
layout: default
---


<div>
    <h2> Introduction </h2>
    <h3> Présentation du groupe </h3>
    <p> Encadrant : Michel Buffa </p>
    <pre>
        SAMAK Maxime
        MUNIER Rémy
        VASSEUR Adrien
        HALLACI Sabri
    </pre>

    <h3> Présentation du sujet </h3>
    <p>
        Le but de ce projet consistait à développer, à l'aide des pistes fournis pas M. Buffa, un jeu multijoueurs à 60 images/secondes, le plus réactif possible. Dans notre cas, un clone du jeu en ligne <a href="http://agar.io">agar.io</a>. Le jeu devait pouvoir être hébergé dans le cloud et être jouable par plusieurs joueurs (16+ joueurs dans une partie). De plus des mesures de latence et de bande passante précises pour évaluer le nombre de joueurs maximal (ou plug généralement d’entités synchronisées) pour une bande passante donnée, avant que ce ne soit injouable, même avec les meilleurs algorithmes font également partie des attentes pour ce projet.
    </p>
    <p>
        Ainsi le travail à effectuer relevait principalement d'établir une architecture client <-> serveur répondant à la demande d'une grande rapidité pour permettre à un jeu multijoueur type arcade d'y être jouable. De même que des algorithmes de prédiction, réconciliation, ... pour conserver un jeu fluide et "agréable" même lors de pics de latence ou plus généralement dans le cas d'une "mauvaise connection".
    </p>

    <h3> Le sujet en quelques images </h3>

        <img src="{{site.baseurl}}/assets/gifs/default_draw.gif" alt="default" width="200" height="180">
        <img src="{{site.baseurl}}/assets/gifs/prediction_draw.gif" alt="prediction" width="200" height="180">
        <img src="{{site.baseurl}}/assets/gifs/prediction_and_reconciliation_draw.gif" alt="prediction and reconciliation" width="200" height="180">
        <p> Tous les gifs ci-dessus ont été capturé à 60 fps</p>

</div>

<div>
    <h2> Technologies utilisés </h2>

    <h3> socket.io </h3>
    <p> <a href="http://socket.io">socket.io</a> est un outil puissant permettant la communication  en temps réel entre un serveur et un ou plusieurs clients. Sa compatibilité avec des technologies récentes tel que les web sockets, mais aussi avec des basiques du networking comme JSON, ... le rende très flexible.
    </p>
    <p> Sa simplicité d'utilisation et notre familiarité avec cette technologie (utilisation lors de différents projets) nous ont poussés à son utilisation pour ce TER.</p>

    <h3> node.js </h3>
    <p> <a href="https://nodejs.org/fr/">node.js</a> est un outil facile d'accès et polyvalent, il est en effet aisé d'héberger un projet node.js de par son support par la plupart des fournisseurs d'hébergement, de même son déploiement sur un serveur personnel ne présente pas de difficultés. </p>
    <p>Un grand nombre de modules sont disponibles pour node.js et parmi ces derniers on fera surtout mention d'<a href="http://expressjs.com/">Express</a> couvrant pour nous la totalité des interactions entre notre client et le serveur.
    </p>

    <h3> p5.js </h3>
    <p> <a href="https://p5js.org/">p5.js</a> est une librairie permettant une certaine facilité dans le développement de contenu créatif, ainsi elle est toute indiquée pour l'élaboration d'un jeu.
     </p>

    <h3> Heroku </h3>
    <p> <a href="https://www.heroku.com/">Heroku</a> est une plateforme d'hébergement orientée cloud, qui nous permet d'héberger notre projet node.js sur un serveur distant, permettant un réel impact sur les vitesses de connections et le multijoueurs de notre projet.
    </p>
</div>

<div>
    <h2> Jeu multijoueurs en temps réel </h2>
    <p> Un jeu multijoueur dit "en temps réel" est un jeu ou les joueurs jouent simultanément, ainsi si l'un se déplace, il doit se déplacer "instantanément" aussi sur les écrans des autres joueurs. Ex : FPS, Mario Kart, agar.io ...
    </p>

    <h3> Networking client-serveur </h3>
    <p>
        Le jeu tourne à l'aide de nodes.js utilisant socket.io pour créer une communication websocket avec un ou plusieurs clients se connectant sur le port 3000 (par défaut).

        <br>
        <img src="{{site.baseurl}}/assets/images/client_server_com.png" alt="connection">
        <br>

        On peut séparer la communication d'un client au serveur en trois étapes distinctes:
        <ol>
            <li> Le client qui se connecte se voit affecter un identifiant unique, et est ajouté à la liste des joueurs actuellement connectés au serveur. On lui attribue également une position de départ ainsi que des informations pour la représentation de son personnage (taille, couleur, ...). </li>
            <li> Le client va ensuite communiquer au serveur la direction vers laquelle il souhaite se déplacer (via tracking de la souris). Le serveur reçoit ces informations les traites et procède aux différentes modifications sur l'état du jeu. </li>
            <li> Périodiquement le serveur va broadcaster la liste des joueurs avec leurs informations mises à jour ainsi que l'état courant du jeu. </li>
        </ol>
        Les étapes 2 et 3 sont reproduites 10 fois par seconde (par défaut), le taux de rafraîchissement du serveur est modifiable via un curseur sur l'interface client.
    </p>

    <h4> Client </h4>
    <p> Le client est la partie du jeu qui s'ouvre dans votre browser, il a la charge de communiquer avec le serveur et de toute la partie graphique du jeu à savoir :
        <ul>
            <li> Le rendu visuel du jeu sur un canvas </li>
            <li> La gestion du menu pour les options </li>
            <li> Le rendu visuel de la courbe de latence </li>
        </ul>
    </p>
    <p> De plus c'est le client qui à l'aide d'algorithmes de prédiction va permettre à l'utilisateur d'avoir une sensation d'agir sur le jeu instantanément à partir d'une dizaine (voir moins) d'updates du serveur à la seconde. Ainsi on pourra même conserver une impression d'avoir 60 fps avec seulement 3 ou 4 updates dans le pire des cas. </p>

    <h4> Serveur </h4>
    <p> C'est sur le serveur que toute la logique du jeu va s'opérer, à partir des directions envoyés par les clients, il va calculer les nouvelles positions des joueurs et changer l'état du jeu en conséquence. </p>
    <p> A chaque update le serveur procède aux opérations suivantes:
        <ul>
            <li>Calcul des nouvelles positions des joueurs à l'aide des vecteurs de position envoyés</li>
            <li>Recherche de collisions entre joueurs</li>
            <li>Recherche de collisions entre les joueurs et les éléments du jeu</li>
            <li>Mise à jour des informations des joueurs</li>
            <li>Broadcast des nouvelles informations</li>

        </ul>
    </p>
    <p> La centralisation de la logique permet à la fois d'éviter toute triche de la part des joueurs, ainsi que de limiter les échanges nécessaires pour faire tourner correctement le jeu (ce choix d'architecture sera détaillé ultérieurement dans le rapport). </p>

    <h3> Hardware et Browser </h3>
    <p> Toutes les machines ne sont pas équivalentes en termes de puissance et donc de rapidité, il en va de même pour les browsers qui de par leurs spécificités propres n'auront pas toujours la même efficacité pour une tâche donnée. </p>
    <p> Une étape essentielle du développement d'un jeu web est donc de pallier à ces inégalités qui toucheront les utilisateurs. </p>

    <h4> Frame rate </h4>
    <p> Prenons un exemple simple pour illustrer ce phénomène : un block se trouve sur un axe X, il se déplace sur cet axe de +1 pixel par frame. Ainsi le joueur A qui fait tourner son jeu à 30 fps verra se déplacer ce block de 30 pixels sur l'axe X en 1 seconde, seulement le joueur B ayant un ordinateur plus performant et ayant 60 fps verra ce même block se déplacer de 60 pixels en 1 seconde. </p>

    <p> Il y a là un véritable problème !</p>

    <p> Solution : pour s'assurer que notre block se déplace toujours à la même vitesse nous allons introduire un concept de delta de temps entre deux rafraîchissements. Cette valeur, exprimée en millisecondes, représente le temps écoulé entre deux itérations de notre boucle de rendu graphique. </p>
    <p> À 30 fps on a donc un delta d'environ 33.3 ms, et à 60 fps on obtient environ 16.66 ms pour notre delta, on peut désormais multiplier notre valeur de déplacement (+1 sur l'axe x) par nos delta pour obtenir un mouvement à 1 pixel par seconde pour nos deux joueurs.</p>

    <br>
    <img src="{{site.baseurl}}/assets/images/deltatime.png" alt="Delta">
    </br>

    <p> Si cet exemple porte uniquement sur les frames rate il ne faut pas oublier que le même principe devrait être appliqué pour toutes valeurs subissant un changement au cours du temps de manière a assurer une cohérence du jeu pour l'ensemble des joueurs. </p>

    <h4> Calcul de la latence </h4>
    <p>
        Un point essentiel lors du dèveloppement et l'usage d'un tel jeu est de pouvoir obtenir des informations fiables sur la latence (et le RTT plus particulièrement). D'un browser à un autre on peut avoir des résultats très différents lors d'un ping test classique en raison d'erreurs d'arrondies, il est donc plus qu'intéressant de faire ce calcul sur le serveur via node.js pour avoir des valuers cohérentes.
    </p>
    <p>On procède de la manière suivante :</p>
    <br>
    <img src="{{site.baseurl}}/assets/images/RTT.png" alt="Round trip time (RTT)">
    </br>
    <p>La récupération des données se fait à l'aide d'un ring buffer et est affiché sous forme de courbe dynamique sur l'interface utilisateur.
    </p>

    <h3> Autre </h3>
    <p> On pourra également noter la présence d'un panneau de contrôle permettant d'activer/désactiver les codes de prédiction/interpolation/... à la volée ainsi que de modifier certains attributs du serveur.</p>

    <h3>Algorithmes</h3>
    <h4>Prédiction client</h4>
    <p>Comme nous l'avons dit, c'est le serveur qui calcule la position des joueurs, le client va envoyer son vecteur de mouvement lors de son gameloop, ce message va arriver au serveur après un décalage équivalent au temps de latence, le serveur calcule puis renvoie au client sa nouvelle position lors de l'update serveur suivante, le message arrive après un nouveau décalage. Il n'est donc pas convenable d'animer le mouvement d'un joueur seulement à l'aide des updates serveur en raison du grand délai entre ces dernières.</p>
    <p>C'est ici qu'entre en fonction l'algorithme de prédiction client :</p>
    <p>Le client va calculer lui-même sa prochaine position avec son vecteur de mouvement, tout en continuant à envoyer ce vecteur au serveur. Le client affiche ensuite la position prédite pour donner l'illusion d'avoir un retour instantané du serveur, on évite ainsi d'avoir à attendre un RTT complet pour pouvoir afficher la nouvelle position du joueur.</p>
    <p>Lors de la prochaine update serveur le joueur devrait donc déjà se trouver à l'emplacement calculé par le serveur. Cependant pour diverses raisons tel qu'un lag coté client ou un pic de charge coté serveur il est possible d'obtenir un décalage entre les deux positions c'est là qu'intervient la réconciliation.</p>
    <pre>
        if (alive) {
            //speed
            let sp = 20;

            let newPosition = createVector(mouseX - width / 2, mouseY - height / 2);
            newPosition.setMag(4);
            newPosition.x = newPosition.x * (delta / sp);
            newPosition.y = newPosition.y * (delta / sp);

            bubble.position.x += newPosition.x;
            bubble.position.y += newPosition.y;

            //bubble.position = createVector(self.x, self.y);
            bubble.radius = self.radius;

            if (bubble.position.x > 3000 - bubble.radius) { bubble.position.x = 3000 - bubble.radius}
            else if (bubble.position.x < -3000 + bubble.radius) { bubble.position.x = -3000 + bubble.radius}
            if (bubble.position.y > 3000 - bubble.radius) { bubble.position.y = 3000 - bubble.radius}
            else if (bubble.position.y < -3000 + bubble.radius) { bubble.position.y = -3000 + bubble.radius}
        }
    </pre>
   
    <h4>Interpolation</h4>
    <p>L'interpolation s'utilise sur les autres joueurs, une implémentation naïve des autres joueurs serait de tout simplement afficher les joueurs à leur nouvelle position a chaque update du serveur, mais cela mène à un rendu très saccadé. La solution apportée est d'enregistrer la dernière position des joueurs et celle tout juste obtenue du serveur et d'interpoler entre les deux pour afficher le mouvement. C'est à dire calculer une liste de points entre les positions t - 2 et t - 1 et animer le mouvement en faisant se déplacer le joueur adverse grâce à ces points. Cela veut toutefois dire que nous affichons les joueurs adverses légèrement en retard par rapport à leurs positions réels (avec un bon taux de rafraichissement serveur cela ne pose aucun problème), au bénéfice d'un affichage fluide et visuellement plus agréable.</p>
    <pre>
        for (let i = 0; i < players.length; i++) {
            if (players[i].id === bubble.id) { continue; }
            else {
                let amount = 1 / (60 / document.getElementById("nbUpdate").value);

                let lastPosition = createVector(players[i].previousX, players[i].previousY);
                let newPosition = createVector(players[i].x, players[i].y);

                let currentPosition = p5.Vector.lerp(lastPosition, newPosition, amount);

                players[i].previousX = currentPosition.x;
                players[i].previousY = currentPosition.y;

                fill(players[i].color.r, players[i].color.g, players[i].color.b);
                ellipse(players[i].previousX, players[i].previousY, players[i].radius * 2);
            }
        }
    </pre>

    <h4>Réconciliation</h4>
    <p>L'objectif de la réconciliation est de faire des "micro" corrections sur la position du joueur affiché par le client pour pallier aux différents décalages qui peuvent survenir lors de la prédiction, elle permet d'avoir un mouvement fluide et fiable ce qui est essentiel aux jeux de type arcade. </p>
    <p> On va donc additioner au vecteur produit par l'algorithme de prédiction un vecteur correctif se rapprochant de la position réel du joueur (la position envoyé par le serveur). Le vecteur correctif est proportionnel au décalage entre la position réel et prédite.</p>
    <pre>
        if (alive) {
            let serverPosition = createVector(self.x, self.y);
            let clientPosition = createVector(bubble.position.x, bubble.position.y);

            let nextPosition = p5.Vector.lerp(clientPosition, serverPosition, 0.1);
            //On corrige le décalage de 10% / frame

            bubble.position = nextPosition;
        }
    </pre>

    <div>
        {% include demo.html %}
    </div>
</div>



<div>
    <h2> Gestion de projet </h2>

    <h3> Organisation </h3>
    <h4> Gestion de source </h4>
    <p> Le projet dans son ensemble s'est accompli à l'air de GIT et github pour la gestion de source/control de version, nous sommes habitués à son utilisation et c'est donc tout naturellement que notre choix s'est porté sur GIT. De plus github offre des fonctionnalités de gestion d'issues ainsi que de Kanban facilitant l'organisation au sein du groupe. </p>

    <h4> Communication et partage des tâches</h4>
    <p> Parallèlement à github et aux issues correspondants aux tâches à réaliser nous avons ouvert un serveur discord dans le but de communiquer de manière plus "instantanée", cela nous a permis par exemple de faire des briefings/debriefings avant/après nos entretients avec M. Buffa, de plus il était plus aisé de demander et de recevoir de l'aide via salons vocaux discord. </p>

    <h3> Travail réalisé </h3>

    <h4>Maxime Samak</h4>
    <p> Fonctionnalités du jeu : Prédiction, Réconciliation, UI, affichage du ping, ring buffer, settings.
        Fonctionnalités serveur : Changement d'architecture, calcul du RTT/latence.
        Ecriture du rapport:  Mise en place de la page github.io, graphiques et images.</p>

    <h4>Rémy Munier</h4>
    <p>Fonctionnalités du jeu : Graphismes, bordure de map, possibilités de « manger » ou d’être mangé, mode spectateur.
        Fonctionnalités serveur : Réglage par les joueurs du « heartbeat » du serveur, Analyse des algorithmes.
        Ecriture du rapport: Récupération et analyse des résultats.</p>

    <h4>Adrien Vasseur</h4>
    <p>
        Pour ma part je me suis concentré surtout sur la partie serveur du projet. Ayant un peu d’expérience avec Nodejs j’ai aidé à mettre en place le serveur et la partie temps réel avec socket.io. Puis j’ai fait implémenté la plupart des éléments du jeu dans le serveur, c’est-à-dire les joueurs, les bulles, et leurs infos respectives (positions, couleurs). Enfin j’ai aidé à synchroniser tous ces élements entre le serveur et tous les clients, de sorte que les clients aient tous les mêmes informations à l’écran. Ainsi, grâce aux websockets, le serveur envoie périodiquement à tout le monde les informations nécessaires pour que le jeu fonctionne en temps réel.
    </p>

    <h4>Sabri Hallaci</h4>
    <p> </p>
</div>

<div>
    <h2> Conclusion </h2>
</div>


